\section{Iterative center of mass displacement compensation algorithm}\label{sec:Algorithm}
In reality, the distribution of the center of mass within the body is not known, and therefore, an analytic solution provided with (\ref{eq:CMsolution2}) is impossible to obtain, thus an iterative method, based on repetitive hopping response is proposed. When a quadruped is continuously jumping, its contact with the ground is infitesimally short, and consequently, reaction forces and torques can be approximated with the Dirac function $\delta (s)$. During the jump, the body behaves according to the Euler body dynamics function (\ref{eq:EulerBody}). Taking account the infitessimally short time the body has to accelerate (i.e. the rotation speeds are small, and their product is event smaller) the cross coupling term $\vec{\omega}\times J_B\vec{\omega}$ can be neglected and, consequently, the rotation speed vector can be approximated with (\ref{eq:RotSpeedAprox}).
\begin{figure}
	\centering
	\includegraphics[width=85mm]{./pictures/RobinRepicCM.pdf}
	\caption{Center of mass displacement}
	\label{fig:CM3Dfunction}
\end{figure}

\begin{equation}\label{eq:EulerBody}
\tau_{tot}=J_B\vec{\dot{\omega}}+\vec{\omega}\times J_B\vec{\omega}
\end{equation}

\begin{equation}\label{eq:RotSpeedAprox}
\vec{\omega}\approx \frac{1}{s}{J_B}^{-1}\begin{bmatrix}
\Delta \textsc{cm}_y & -\Delta \textsc{cm}_x & 0
\end{bmatrix}^T\bar{T}\delta(s)
\end{equation}

Calculating the absolute value of vector (\ref{eq:RotSpeedAprox}) it is easy to show that the size of the rotation speed vector is proportional to the displacement of center of mass \eqref{eq:WpropCM}. In other words, centering the robot and minimizing the displacement of the center of mass eliminates the generation of unwanted rotations. 

\begin{equation}\label{eq:WpropCM}
\left \| \vec{\omega} \right \|\sim \sqrt{{\Delta \textsc{cm}_x}^2+{\Delta \textsc{cm}_y}^2}
\end{equation}


In order to iteratively calculate the angles $q1$ and $q2$, angular velocity vector is recorded during the hopping acceleration phase. In order to start the jump procedure, the initial actuated spring value $L_{i0}$ is changed for a small value $\delta L$:

\begin{equation}
\tiny
L_{i1}=L_{i0}+\delta L
\normalsize
\end{equation}  

This phase is completed ($t_{JC}$) when one of the legs/springs reaches the desired length $L_{i1}$. The leg which carries a minimum weight (i.e. attached to a cuboid of minimal mass) will achieve the fastest accelerations and the algorithmâ€™s task is to navigate the tail towards this leg. At the end of the acceleration phase the body rotates with an angular velocity $\vec{\omega}(t_{JC})$. By using the cross product of the projection vector $\vec{\omega_{xy}}$ in $XY$ plane and the body $\vec{Zb}$, the tail direction vector $\vec{\omega_{TD}}$ is calculated (see Fig.\ref{fig:imassCom}). The tail motion control algorithm navigates the tail in $\vec{\omega_{TD}}$ direction by using the simple P($K_o$) controller. The algorithm finishes when $\left \| \vec{\omega}(t_{JC}) \right \|\ $ is smaller than the  predefined limit value $\omega_{max}$.  For example, the mass distribution in Fig.\ref{fig:imassCom} is equally distributed except for $MASS_2$  which is lighter than the others. As expected, the iterative algorithm will navigate the tail towards that mass.



\begin{algorithm}
\caption{Minimize $\left \| \vec{\omega} \right \|\sim \sqrt{{\Delta \textsc{cm}_x}^2+{\Delta \textsc{cm}_y}^2}$}
\begin{algorithmic} 
\STATE $y \leftarrow 1$
\REPEAT
\STATE $Q_1 \leftarrow$ initial value
\STATE $Q_2 \leftarrow$ initial value
\STATE JUMP

\REPEAT
\STATE recording $\vec{\omega}(t)$
\UNTIL JUMP COMPLETE
\STATE $\vec{\omega_{TD}} = \vec{\omega_{xy}}(t_{JC}) \times \vec{Zb}$
\STATE Move tail in $\vec{\omega_{TD}}$ direction - gain $K_o$
\UNTIL{$\left \| \vec{\omega}(t_{JC}) \right \|\ < \omega_{max}$}
\end{algorithmic}
\end{algorithm}


\begin{figure}
	\centering
	\includegraphics[width=85mm]{./pictures/IterativeAlgorithm.pdf}
	\caption{Iterative mass displacement compensation}
	\label{fig:imassCom}
\end{figure}
